package fsm

import (
	"context"
	"errors"

	"github.com/birchwood-langham/bootstrap/pkg/logger"
	"github.com/google/uuid"
	"go.uber.org/zap"
)

type Machine interface {
	// ID returns the unique id of the state machine
	ID() uuid.UUID
	// Name returns the name assigned to the state machine
	Name() string
	// Current returns a description of the current state of the machine
	Current() string
	// Run executes the state machine
	Run(context.Context, <-chan Event) error
}

type machine struct {
	id      uuid.UUID
	name    string
	current State
	errCh   chan error
	hasRun  bool
}

// New creates a state machine with the given initial state
// and a channel where any errors generated by the state machine will
// be published
func New(id uuid.UUID, name string, init State) (m *machine, errCh chan error) {
	m = new(machine)
	m.id = id
	m.name = name
	m.current = init
	m.hasRun = false
	errCh = make(chan error)
	m.errCh = errCh
	return
}

func (m *machine) ID() uuid.UUID {
	return m.id
}

func (m *machine) Name() string {
	return m.name
}

func (m *machine) Current() string {
	return m.current.Description()
}

// Run executes the state machine with the given context
// A state machine can only be run once, once the state machine has started its run, it will
// return an error if Run is called again.
// Run takes an event channel for events to be passed to the state machine, if the events channel
// is closed, the state machine will exit.
// Run will close the error channel automatically when processing has been completed
func (m *machine) Run(ctx context.Context, eventCh <-chan Event) error {
	if m.hasRun {
		return errors.New("state machine has already been run and cannot be re-run, you need to create a new state machine")
	}

	m.hasRun = true

	l := logger.Logger()

	defer close(m.errCh)

	for {
		select {
		case <-ctx.Done():
			l.Warn("Context has ended, stopping state machine")
			return nil
		case event, ok := <-eventCh:
			if !ok {
				l.Warn("Incoming event channel has been closed, terminating state machine")
				return nil
			}

			l.Info("Received event",
				zap.String("name", event.Name()),
				zap.String("source", event.Source()),
				zap.String("id", event.ID().String()),
				zap.String("timestamp", TimestampToString(event.Timestamp())),
			)

			err := m.current.Execute(event)

			if err != nil {
				l.Error("Processing event resulted in error", zap.Error(err))
				m.errCh <- err
				continue
			}

			next := m.current.Next()
			if next == nil {
				return nil
			}

			if next.ID() != m.current.ID() {
				l.Info("State machine transitioning to new state",
					zap.String("current", m.current.Description()),
					zap.String("next", next.Description()),
				)
			}

			m.current = next
		}
	}
}
